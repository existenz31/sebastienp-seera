// This model was generated by Lumber. However, you remain in control of your models.
// Learn how here: https://docs.forestadmin.com/documentation/v/v6/reference-guide/models/enrich-your-models
module.exports = (sequelize, DataTypes) => {
  const { Sequelize} = sequelize;

  // This section contains the fields of your model, mapped to your table's columns.
  // Learn more here: https://docs.forestadmin.com/documentation/v/v6/reference-guide/models/enrich-your-models#declaring-a-new-field-in-a-model
  const Property = sequelize.define('property', {
    nameAr: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    nameEn: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    thumbnailImageUrl: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    addressEn: {
      type: DataTypes.STRING,
    },
    addressAr: {
      type: DataTypes.STRING,
    },
    checkInFrom: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    checkInTo: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    checkOutFrom: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    checkOutTo: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    latitude: {
      type: DataTypes.DOUBLE,
      allowNull: false,
    },
    longitude: {
      type: DataTypes.DOUBLE,
      allowNull: false,
    },
    ownedBy: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
    },
    createdAt: {
      type: DataTypes.DATE,
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
    },
    updatedAt: {
      type: DataTypes.DATE,
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    originalNameEn: {
      type: DataTypes.STRING,
      defaultValue: null,
    },
    originalNameAr: {
      type: DataTypes.STRING,
      defaultValue: null,
    },
    compoundId: {
      type: DataTypes.INTEGER,
    },
    privacy: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
    },
    contact: {
      type: DataTypes.STRING,
      defaultValue: "guard",
      allowNull: false,
    },
    capacity: {
      type: DataTypes.INTEGER,
      defaultValue: 4,
    },
    size: {
      type: DataTypes.INTEGER,
      defaultValue: 980,
    },
    unitNumber: {
      type: DataTypes.STRING,
    },
    countryNameEn: {
      type: DataTypes.STRING,
    },
    countryNameAr: {
      type: DataTypes.STRING,
    },
    cityNameEn: {
      type: DataTypes.STRING,
    },
    cityNameAr: {
      type: DataTypes.STRING,
    },
    regionNameEn: {
      type: DataTypes.STRING,
    },
    regionNameAr: {
      type: DataTypes.STRING,
    },
    areaNameEn: {
      type: DataTypes.STRING,
    },
    areaNameAr: {
      type: DataTypes.STRING,
    },
  }, {
    tableName: 'property_view',
    underscored: true,
    schema: process.env.DATABASE_SCHEMA,
    hooks: {
      afterFind: async (properties) => {
        // Check if several records have been fetched or a single one
        const isFindOne = !properties.length;
        if (isFindOne) { properties = [properties]; }
        const recordsIds = properties.map(record => record.locationIdKey);
        const locations = await sequelize.models.location.findAll({
          where: { id: recordsIds },
          include: [{
            model: sequelize.models.country,
            as: 'countryCode'
          }, {
            model: sequelize.models.city,
            as: 'city'
          }, {
            model: sequelize.models.region,
            as: 'region'
          }, {
            model: sequelize.models.area,
            as: 'area'
          }]          
        });

        properties.forEach((property) => {
          let location = locations.filter( (loc) => loc.id = property.locationIdKey);
          location = location.length?location[0]: null;
          if (location) {
            property.country = location.countryCode;
            property.city = location.city;
            property.region = location.region;
            property.area = location.area;              
          }
        });

        return isFindOne ? properties[0] : properties;
      },
    },    
  });

  // This section contains the relationships for this model. See: https://docs.forestadmin.com/documentation/v/v6/reference-guide/relationships#adding-relationships.
  Property.associate = (models) => {
    Property.belongsTo(models.location, {
      foreignKey: {
        name: 'locationIdKey',
        field: 'location_id',
      },
      as: 'location',
    });
    Property.belongsTo(models.propertyType, {
      foreignKey: {
        name: 'propertyTypeIdKey',
        field: 'property_type_id',
      },
      as: 'propertyType',
    });
    Property.hasMany(models.propertyAdditionalInfo, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyAdditionalInfos',
    });
    Property.hasMany(models.propertyAmenity, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyAmenities',
    });
    Property.hasMany(models.propertyBooking, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyBookings',
    });
    Property.hasMany(models.propertyBookingAud, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyBookingAuds',
    });
    Property.hasMany(models.propertyDescription, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyDescriptions',
    });
    Property.hasMany(models.propertyGuestType, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyGuestTypes',
    });
    Property.hasMany(models.propertyMedia, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyMedias',
    });
    Property.hasMany(models.propertyPolicy, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyPolicies',
    });
    Property.hasMany(models.propertyPool, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyPools',
    });
    Property.hasMany(models.propertyPrice, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyPrices',
    });
    Property.hasMany(models.propertyRoom, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyRooms',
    });
    Property.hasMany(models.propertyRule, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'propertyRules',
    });
    Property.hasMany(models.bathroom, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'bathrooms',
    });
    Property.hasMany(models.bookingTransaction, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'bookingTransactions',
    });
    Property.hasMany(models.image, {
      foreignKey: {
        name: 'propertyIdKey',
        field: 'property_id',
      },
      as: 'images',
    });
    Property.hasMany(models.poolAmenity, {
      foreignKey: {
        name: 'poolIdKey',
        field: 'pool_id',
      },
      as: 'poolPoolAmenities',
    });
  };


  return Property;
};
